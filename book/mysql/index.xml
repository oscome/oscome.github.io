<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MySQL on </title>
    <link>https://oscome.cn/book/mysql/</link>
    <description>Recent content in MySQL on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 10 Oct 2022 10:28:28 +0800</lastBuildDate><atom:link href="https://oscome.cn/book/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基础知识</title>
      <link>https://oscome.cn/book/mysql/%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 10 Oct 2021 10:28:28 +0800</pubDate>
      
      <guid>https://oscome.cn/book/mysql/%E5%9F%BA%E7%A1%80/</guid>
      <description>数据库范式   第一范式（1NF）：原子性，不可再分解 第二范式（2NF）：唯一性，在第一范式基础上，非主键列完全依赖于主键 第三范式（3NF）：独立性，在第二范式的基础上，非主键列依赖于主键，不依赖于其他非主键，消除传递依赖 其他：巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）  语句类别   DDL(Database Defination Language):create、alter等 DML(Database Manipulation Language):insert、update、delete等 DCL(Database Control Language):grant、revoke等 DQL(Database Query Language):select  事务  事务相关命令   显式启动事务语句，begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。
 建议总是使用set autocommit=1, 通过显式语句的方式来启动事务。
ACID   A (Atomicity) 原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样 C (Consistency) 一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏 I (Isolation) 隔离性：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰 D (Durability) 持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚  隔离级别   读未提交，一个事务还没提交时，它做的变更就能被别的事务看到。 读提交，一个事务提交之后，它做的变更才会被其他事务看到。 可重复读，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。 串行化，顾名思义，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。  数据库隔离级别不够时容易出现3种情况：
 脏读：即事务A读取到了事务B未提交的数据。该数据可能不是最终数据而是中间变量，因此会导致事务A读取到错误的数据。 不可重复读：即事务A多次访问同一个数据，获得结果不相同。在访问间隔时，事务A访问数据被事务B修改，导致事务A多次读取到不一样的数据值。 幻读：即事务A在读取某些数据时，事务B通过插入或删除等方式对数据集进行了修改，导致事务A读取到了事务B执行后的结果。  下面是个级别可能发生的情况：
MySQL 的执行流程  大体来说，MySQL可以分为Server层和存储引擎层两部分。Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://oscome.cn/book/mysql/%E9%AB%98%E5%8F%AF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://oscome.cn/book/mysql/%E9%AB%98%E5%8F%AF%E7%94%A8/</guid>
      <description>MySQL性能与可用性分析  日志   重做日志（redo log）：确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。 回滚日志（undo log）：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），即非锁定读 二进制日志，归档日志（binlog）：用于复制和备份，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。 也可基于时间点做数据库的的还原。 其他还有常见的慢日志、查询日志、错误日志  我们主要看一下前面3个日志，来理解MySQL是如何利用这些日志和一些特殊的机制保证可用性的。
redo log 重做日志  在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。
WAL(Write-Ahead Loggin)机制   在MySQL里，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新。整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。
 具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。
另外，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。
write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。
write pos和checkpoint之间的是空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。
有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。
redo log的三种状态：
 红色：存在redo log buffer中，物理上是在MySQL进程内存中 黄色：写到磁盘(write)，但是没有持久化（fsync)，物理上是在文件系统的page cache里面 绿色：持久化到磁盘，对应的是hard disk  为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参 数，它有三种可能取值:
 0，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ; 1，表示每次事务提交时都将 redo log 直接持久化到磁盘; 2 ，表示每次事务提交时都只是把 redo log 写到 page cache。  InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写 到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</description>
    </item>
    
  </channel>
</rss>
