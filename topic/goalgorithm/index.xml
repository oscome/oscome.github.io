<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小欧的算法笔记 on </title>
    <link>https://oscome.cn/topic/goalgorithm/</link>
    <description>Recent content in 小欧的算法笔记 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 26 Sep 2022 08:48:18 +0800</lastBuildDate><atom:link href="https://oscome.cn/topic/goalgorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>说明</title>
      <link>https://oscome.cn/topic/goalgorithm/start/</link>
      <pubDate>Mon, 26 Sep 2022 08:48:18 +0800</pubDate>
      
      <guid>https://oscome.cn/topic/goalgorithm/start/</guid>
      <description>小欧的算法笔记，主要语言 Go</description>
    </item>
    
    <item>
      <title>day1 为什么要学习算法与数据结构</title>
      <link>https://oscome.cn/topic/goalgorithm/1/</link>
      <pubDate>Sat, 01 Oct 2022 12:48:18 +0800</pubDate>
      
      <guid>https://oscome.cn/topic/goalgorithm/1/</guid>
      <description>最近正好在回顾算法与数据结构，顺便把笔记沉淀下来，分享出来，希望对你有所帮助。
什么是数据结构？什么是算法？   数据结构就是指一组数据的存储结构 算法就是操作数据的方法 数据结构和算法是相辅相成的，数据结构是为算法服务的，而算法一般是建立在特定的数据结构之上  算法和数据结构的学习目的   实用而“有趣” 应付面试算法题 提升编程软实力  学习方法   各个击破，系统学习 练习，练习，练习  针对弱点 克服枯燥 有不舒适的感觉就对了   沉淀文档，方便复习 持续过程  练习平台   力扣  </description>
    </item>
    
    <item>
      <title>day2 算法复杂度</title>
      <link>https://oscome.cn/topic/goalgorithm/2/</link>
      <pubDate>Sun, 02 Oct 2022 16:48:18 +0800</pubDate>
      
      <guid>https://oscome.cn/topic/goalgorithm/2/</guid>
      <description>算法复杂度  算法的复杂度指的是执行该算法的程序在运行时所需要的时间和空间(内存)资源，复杂度分析一般从时间复杂度和空间复杂度两个层面来考虑。
时间复杂度   描述算法运行时长的量度， T(n) = O(f(n))，函数T(n) 为算法操作执行次数，O为算法的渐进时间复杂度，简称时间复杂度。
 空间复杂度   一个算法在运行过程中临时占用存储空间大小的量度，记作 S(n)=O(f(n))
 常见的复杂度量级从低到高：
 常数阶O(1) 对数阶O(logN) 线性阶O(n) 线性对数阶O(nlogN) 平方阶O(n²) 立方阶O(n³) K次方阶O(n^k)（k&amp;gt;3） 指数阶(2^n)  最高次量级即为当前算法的复杂度。
拓展知识   主定理（Master Theorem）  </description>
    </item>
    
    <item>
      <title>day3 数组</title>
      <link>https://oscome.cn/topic/goalgorithm/3/</link>
      <pubDate>Mon, 03 Oct 2022 11:48:18 +0800</pubDate>
      
      <guid>https://oscome.cn/topic/goalgorithm/3/</guid>
      <description>定义   数组（Array）是有限个相同类型的变量组成的有序集合。
 特点   线性 连续的内存空间 存储相同类型数据  数组因为有连续的内存空间和相同类型的数据，它才有了一个特性：随机访问。根据下标访问数组的时间复杂度是 O(1)。
但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作，效率可想而知。
低效的插入和删除  假设数组的长度为n，如果我们需要将一个数据插入到数组中的第k个位置。为了把第k个位置腾给新来的数据，我们需要将第k～n这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？
显然，跟这个k的位置有极大的关系。
 如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为O(1)。 如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是O(n)。  因为我们在每个位置插入元素的概率是一样的，所以平均时间复杂度为(1+2+…n)/n=O(n)。
如果数据有序，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移k之后的数据。但是，如果数组无序，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第k个位置，为了避免大规模的数据搬移，我们有一个简单的办法，直接将第k位的数据搬移到数组元素的最后，把新元素直接放入第k个位置。这种特殊的处理技巧，可以在特定场景下(比如数组无序)将插入元素的时间复杂度降到 O(1)。这个处理思想在快排中会用到。
和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为O(1)；如果删除开头的数据，则最坏情况时间复杂度为O(n)；平均情况时间复杂度也为O(n)。
实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？
我们来看一个例子。数组a[10]中存储了8个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除a，b，c三个元素。
为了避免d，e，f，g，h这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。
这不就是JVM标记清除垃圾回收算法的核心思想吗？
数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。
补充   线性表（Linear List）  线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。
题目  加一 [easy]  66. 加一
给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。
示例 1： 输入：digits = [1,2,3] 输出：[1,2,4] 解释：输入数组表示数字 123。 示例 2： 输入：digits = [4,3,2,1] 输出：[4,3,2,2] 解释：输入数组表示数字 4321。 示例 3： 输入：digits = [0] 输出：[1]  func plusOne(digits []int) []int { ret := make([]int,1) btn := 0 // 标记是否进1 l := len(digits) for i:=l-1; i &amp;gt;=0; i-- { digits[i]+=btn btn = 0 if i == l - 1 { digits[i]++ } if digits[i] == 10 { btn = 1 digits[i]=digits[i]-10 } } if btn == 1 { ret[0] = 1 ret = append(ret, digits.</description>
    </item>
    
    <item>
      <title>day4 链表</title>
      <link>https://oscome.cn/topic/goalgorithm/4/</link>
      <pubDate>Sat, 01 Oct 2022 17:48:18 +0800</pubDate>
      
      <guid>https://oscome.cn/topic/goalgorithm/4/</guid>
      <description>定义   一种在物理上非连续、非顺序的数据结构，由若干个节点组成。
 题目  反装链表  https://leetcode.cn/problems/reverse-linked-list/
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]
输入：head = [1,2] 输出：[2,1]
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { var prev, tmp *ListNode for head != nil { tmp = head.Next head.Next = prev prev = head head = tmp } return prev }  K 个一组翻转链表  https://leetcode.</description>
    </item>
    
  </channel>
</rss>
