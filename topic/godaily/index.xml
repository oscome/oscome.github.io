<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>godaily 每日一库 on </title>
    <link>https://oscome.cn/topic/godaily/</link>
    <description>Recent content in godaily 每日一库 on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 26 Sep 2022 08:48:18 +0800</lastBuildDate><atom:link href="https://oscome.cn/topic/godaily/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>godaily 每日一库</title>
      <link>https://oscome.cn/topic/godaily/godaily/</link>
      <pubDate>Mon, 26 Sep 2022 08:48:18 +0800</pubDate>
      
      <guid>https://oscome.cn/topic/godaily/godaily/</guid>
      <description>一天更新一个 golang 库，每天练习，不断进步。</description>
    </item>
    
    <item>
      <title>day1-cast 类型转换</title>
      <link>https://oscome.cn/topic/godaily/cast/</link>
      <pubDate>Mon, 26 Sep 2022 10:48:18 +0800</pubDate>
      
      <guid>https://oscome.cn/topic/godaily/cast/</guid>
      <description>引言 # 是否还在为golang麻烦的类型转换烦恼？
尝试一下 spf13 大神的 cast 吧。
项目地址 #  项目地址： https://github.com/spf13/cast[star:2.5k]
 安装 #  go get github.com/spf13/cast
 例子 # package day001 import ( &amp;quot;testing&amp;quot; &amp;quot;github.com/spf13/cast&amp;quot; ) func TestCast(t *testing.T) { t.Log(&amp;quot;cast.ToString&amp;quot;) t.Log(cast.ToString(&amp;quot;https://oscome.cn&amp;quot;)) t.Log(cast.ToString(8.88)) t.Log(cast.ToString([]byte(&amp;quot;https://oscome.cn&amp;quot;))) var abc interface{} = &amp;quot;https://oscome.cn&amp;quot; t.Log(cast.ToString(abc)) t.Log(&amp;quot;cast.ToInt&amp;quot;) t.Log(cast.ToInt(&amp;quot;8&amp;quot;)) // 后面+E 可以多返回一个 error 参数 t.Log(cast.ToInt64E(&amp;quot;8.99&amp;quot;)) t.Log(&amp;quot;cast.ToInt&amp;quot;) t.Log(cast.ToBool(&amp;quot;1&amp;quot;)) t.Log(cast.ToBool(&amp;quot;8.99&amp;quot;)) }  效果如下： cast不止如此，除了常见类型，还提供了时间类方法 ToTime、ToDuration，甚至还有切片类转换 ToStringSlice、ToStringMap，强大又好用。
func TestCastMore(t *testing.T) { t.Log(&amp;quot;cast.ToTime&amp;quot;) t.Log(cast.ToTime(&amp;quot;2022-01-02 01:01:01 +0000 UTC&amp;quot;)) t.</description>
    </item>
    
    <item>
      <title>day2-viper 配置读取</title>
      <link>https://oscome.cn/topic/godaily/viper/</link>
      <pubDate>Tue, 27 Sep 2022 10:48:18 +0800</pubDate>
      
      <guid>https://oscome.cn/topic/godaily/viper/</guid>
      <description>引言 # viper 是一个用于读取配置文件的库。如果你需要读取配置文件，那么 viper 足够好用。
项目地址 #  项目地址： https://github.com/spf13/viper [star:20.7k]
 安装 #  go get github.com/spf13/viper
 例子 # 我们可以增加一个文件
# oscome.yaml name: oscome mode: debug log: level: debug  我们可以使用 viper 读取这个配置文件，并且配合 fsnotify 监听配置，监听的好处就在于运行中配置几乎实时生效，无需重启服务。
package day002 import ( &amp;quot;fmt&amp;quot; &amp;quot;testing&amp;quot; &amp;quot;time&amp;quot; &amp;quot;github.com/fsnotify/fsnotify&amp;quot; &amp;quot;github.com/spf13/viper&amp;quot; ) func read() { viper.AddConfigPath(&amp;quot;.&amp;quot;) // 还可以在工作目录中查找配置 viper.SetConfigFile(&amp;quot;oscome.yaml&amp;quot;) // 指定配置文件路径(这一句跟下面两行合起来表达的是一个意思) // viper.SetConfigName(&amp;quot;oscome&amp;quot;) // 配置文件名称(无扩展名) // viper.SetConfigType(&amp;quot;yaml&amp;quot;) // 如果配置文件的名称中没有扩展名，则需要配置此项 err := viper.ReadInConfig() // 配置文件 if err !</description>
    </item>
    
    <item>
      <title>day3-urfave/cli 命令行</title>
      <link>https://oscome.cn/topic/godaily/urfavecli/</link>
      <pubDate>Wed, 28 Sep 2022 10:48:18 +0800</pubDate>
      
      <guid>https://oscome.cn/topic/godaily/urfavecli/</guid>
      <description>引言 # urfave/cli是一个简单、快速、有趣的包，用于在 Go 中构建命令行应用程序。目标是使开发人员能够以富有表现力的方式编写快速且可分发的命令行应用程序。
项目地址 #  项目地址： https://github.com/urfave/cli [star:19k]
 安装 #  go get github.com/urfave/cli/v2
 例子 # 作为一个命令行工具，urfave/cli 足够好用，你可以自定义参数、版本、说明&amp;hellip;&amp;hellip;
我们来个 🌰 ，参数说明可看备注。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;os&amp;quot; &amp;quot;github.com/urfave/cli/v2&amp;quot; ) func main() { var language string app := &amp;amp;cli.App{ Name: &amp;quot;godaily day003&amp;quot;, // cli name Version: &amp;quot;v13&amp;quot;, // cli version Usage: &amp;quot;godaily day003 test&amp;quot;, // usage Flags: []cli.Flag{ // 接受的 flag &amp;amp;cli.StringFlag{ // string Name: &amp;quot;lang&amp;quot;, // flag 名称 Aliases: []string{&amp;quot;l&amp;quot;}, // 别名 Value: &amp;quot;english&amp;quot;, // 默认值 Usage: &amp;quot;language for the greeting&amp;quot;, Destination: &amp;amp;language, // 指定地址，如果没有可以通过 *cli.</description>
    </item>
    
    <item>
      <title>day5-内存 cache2go</title>
      <link>https://oscome.cn/topic/godaily/cache2go/</link>
      <pubDate>Thu, 29 Sep 2022 12:48:18 +0800</pubDate>
      
      <guid>https://oscome.cn/topic/godaily/cache2go/</guid>
      <description>引言 # cache2go 是个并发安全的续期式的缓存库，适合存储少量常驻内存变量。
项目地址 #  项目地址： &amp;lt;a ta&amp;rsquo;r&amp;rsquo;ge&amp;quot;https://github.com/muesli/cache2go&amp;quot;&amp;gt;https://github.com/muesli/cache2go [star:1.8k]
 安装 #  go get github.com/muesli/cache2go
 例子 # 具体方法可见注释
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; &amp;quot;github.com/muesli/cache2go&amp;quot; ) type myStruct struct { title string content interface{} } func main() { table := &amp;quot;test&amp;quot; key := &amp;quot;oscome&amp;quot; // 新建 CacheTable cache := cache2go.Cache(table) setDataLoader(table) Callback(table, key) val := myStruct{&amp;quot;what&amp;quot;, &amp;quot;hello oscome&amp;quot;} // 添加一个kv，过期时间 2s cache.Add(key, 2*time.Second, &amp;amp;val) // 获取value res, err := cache.</description>
    </item>
    
  </channel>
</rss>
